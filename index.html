<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Elementary Cellular Automata</title>
        <style>
            body * {
                padding: 0px;
            }
            .row {
                margin: 0px;
                line-height: 0;
            }
            .row div {
                height: 5px;
                width: 5px;
                margin: 1px;
                display: inline-block;
            }
            .row div.active {
                background-color: red;
            }
            .row div.inactive {
                background-color: #99ccff;
            }
        </style>
    </head>
    <body>
        <main>
            <h1>Elementary Cellular Automata</h1>
            <a href="http://atlas.wolfram.com/01/01/73/">based on rule 73</a>
            <div id="automaton">
                <div class="row"></div>
            </div>
        </main>
        <script>

          const randomBinary = () => {
            let max = 1,
                min = 0;
            return Math.floor(Math.random() * ( max - min + 1 ));
          };

          const initializeRow = (size, createDiv, row) => {
            for (let i = 0; i < size; i++) {
              let div = createDiv();
              row.appendChild(div);
            }
          };

          const seedRow = (rowDiv, state) => {
            Array.from(rowDiv.childNodes).map( state )
          };


          const randomSeed = ( div )=> {
            div.classList.add( randomBinary() ? 'inactive' : 'active');
          };

          const centerActiveSeed = ( div, i, arr ) => {
            const middle = arr.length/2;
            if ( i === middle ) {
              div.classList.add( 'active');
            } else {
              div.classList.add( 'inactive'  );
            }
          };

          let checkState = (cellDiv) => cellDiv.classList.contains('active') ? 1 : 0;

          let processRow = (rowDiv, parentRow) => {
            for (let i = 0; i < rowDiv.childNodes.length; i++) {
              let target = rowDiv.childNodes[i];
              let prevSelf = parentRow.childNodes[i];
              let leftSibling = prevSelf.previousElementSibling || parentRow.childNodes[parentRow.childNodes.length - 1];
              let rightSibling = prevSelf.nextElementSibling    || parentRow.childNodes[0];
              let check = applyRules.bind(null, target, leftSibling, prevSelf, rightSibling);
              //  based on rule 73
              //  http://atlas.wolfram.com/01/01/73/
              check([1, 1, 1], 0);
              check([1, 1, 0], 1);
              check([1, 0, 1], 0);
              check([1, 0, 0], 0);
              check([0, 1, 1], 1);
              check([0, 1, 0], 0);
              check([0, 0, 1], 0);
              check([0, 0, 0], 1);
            }
          };

          // needs to be a function, not arrow function because of binding.
          function applyRules( target, leftSibling, prevSelf, rightSibling, rule, state ) {
            let result = ( checkState(leftSibling) === rule[0] && checkState(prevSelf) === rule[1] && checkState(rightSibling) === rule[2] )
            if ( result ) setState(target,state)
          }

          const setActive = (cellDiv) => {
            cellDiv.classList.add('active');
            cellDiv.classList.remove('inactive');
          };

          const setInActive = (cellDiv) => {
            cellDiv.classList.remove('active');
            cellDiv.classList.add('inactive');
          };

          const setState = (cellDiv, state) => {
            if (state===1) {
              setActive(cellDiv)
            } else {
              setInActive(cellDiv)
            }
          };

          const duplicateRow = (n, baseDivLocator ) => {
            for (let i = 0; i < n; i++) {
              let allRows = document.querySelectorAll('.row');
              let lastRow = allRows[allRows.length - 1];
              let clone = lastRow.cloneNode(true);
              baseDivLocator().appendChild(clone);
              processRow(clone, lastRow);
            }
          };

          const reset = () => {
            let automaton = document.getElementById('automaton');
            while(automaton.firstChild) {
              automaton.removeChild(automaton.firstChild);
            }
            let row  = document.createElement('div');
            row.classList.add('row');
            automaton.appendChild(row);
          };

          const randomRowStart = () => {
            reset();
            initializeRow(100, () => document.createElement('div'), document.querySelector('.row'));
            seedRow(document.querySelector('.row'), randomSeed);
            duplicateRow(200, () => document.getElementById('automaton'));
          };

          const centerRowStart = () => {
            reset();
            initializeRow(100, ()=>document.createElement('div'), document.querySelector('.row') );
            seedRow(document.querySelector('.row'), centerActiveSeed );
            duplicateRow(200, ()=> document.getElementById('automaton') );
          };

          centerRowStart();
          setInterval(randomRowStart,2000);
          setInterval(centerRowStart,4000);

        </script>
    </body>
</html>
